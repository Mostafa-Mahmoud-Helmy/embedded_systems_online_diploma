/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#define RCC_BASE 	    0x40021000
#define GPIOA_BASE  	0x40010800
#define GPIOB_BASE  	0x40010C00

typedef union{
	volatile unsigned long ALL_FIELDS;
	struct {
		volatile unsigned long AFIOEN:1;
		volatile unsigned long :1;
		volatile unsigned long IOPAEN:1;
		volatile unsigned long IOPBEN:1;
		volatile unsigned long IOPCEN:1;
		volatile unsigned long IOPDEN:1;
		volatile unsigned long IOPEEN:1;
		volatile unsigned long IOPFEN:1;
		volatile unsigned long IOPGEN:1;
	}bits;
}APB2ENR;

typedef union{
	volatile unsigned long ALL_FIELDS;
	struct {
		volatile unsigned long MODE0 :2;
		volatile unsigned long CNF0 :2;

		volatile unsigned long MODE1 :2;
		volatile unsigned long CNF1 :2;

		volatile unsigned long MODE2 :2;
		volatile unsigned long CNF2:2;

		volatile unsigned long MODE3 :2;
		volatile unsigned long CNF3 :2;

		volatile unsigned long MODE4 :2;
		volatile unsigned long CNF4 :2;

		volatile unsigned long MODE5 :2;
		volatile unsigned long CNF5 :2;

		volatile unsigned long MODE6 :2;
		volatile unsigned long CNF6 :2;

		volatile unsigned long MODE7 :2;
		volatile unsigned long CNF7 :2;
	}bits;
}GPIOx_CRL;

typedef union{
	volatile unsigned long ALL_FIELDS;
	struct {
		volatile unsigned long MODE8 :2;
		volatile unsigned long CNF8 :2;

		volatile unsigned long MODE9 :2;
		volatile unsigned long CNF9 :2;

		volatile unsigned long MODE10 :2;
		volatile unsigned long CNF10 :2;

		volatile unsigned long MODE11 :2;
		volatile unsigned long CNF11 :2;

		volatile unsigned long MODE12 :2;
		volatile unsigned long CNF12 :2;

		volatile unsigned long MODE13 :2;
		volatile unsigned long CNF13 :2;

		volatile unsigned long MODE14 :2;
		volatile unsigned long CNF14 :2;

		volatile unsigned long MODE15 :2;
		volatile unsigned long CNF15 :2;
	}bits;
}GPIOx_CRH;

typedef union{
	volatile unsigned long ALL_FIELDS;
	struct {
		volatile unsigned long IDR0:1;
		volatile unsigned long IDR1:1;
		volatile unsigned long IDR2:1;
		volatile unsigned long IDR3:1;
		volatile unsigned long IDR4:1;
		volatile unsigned long IDR5:1;
		volatile unsigned long IDR6:1;
		volatile unsigned long IDR7:1;
		volatile unsigned long IDR8:1;
		volatile unsigned long IDR9:1;
		volatile unsigned long IDR10:1;
		volatile unsigned long IDR11:1;
		volatile unsigned long IDR12:1;
		volatile unsigned long IDR13:1;
		volatile unsigned long IDR14:1;
		volatile unsigned long IDR15:1;

	}bits;
}GPIOx_IDR;

typedef union{
	volatile unsigned long ALL_FIELDS;
	struct {
		volatile unsigned long ODR0:1;
		volatile unsigned long ODR1:1;
		volatile unsigned long ODR2:1;
		volatile unsigned long ODR3:1;
		volatile unsigned long ODR4:1;
		volatile unsigned long ODR5:1;
		volatile unsigned long ODR6:1;
		volatile unsigned long ODR7:1;
		volatile unsigned long ODR8:1;
		volatile unsigned long ODR9:1;
		volatile unsigned long ODR10:1;
		volatile unsigned long ODR11:1;
		volatile unsigned long ODR12:1;
		volatile unsigned long ODR13:1;
		volatile unsigned long ODR14:1;
		volatile unsigned long ODR15:1;
	}bits;
}GPIOx_ODR;


volatile APB2ENR   * RCC_APB2ENR    = (volatile APB2ENR   *)(RCC_BASE 	+0x18);

volatile GPIOx_CRL * GPIOA_CRL      = (volatile GPIOx_CRL *)(GPIOA_BASE	+0x00);
volatile GPIOx_CRH * GPIOA_CRH      = (volatile GPIOx_CRH *)(GPIOA_BASE +0x04);
volatile GPIOx_IDR * GPIOA_IDR      = (volatile GPIOx_IDR *)(GPIOA_BASE +0x08);
volatile GPIOx_ODR * GPIOA_ODR      = (volatile GPIOx_ODR *)(GPIOA_BASE +0x0C);

volatile GPIOx_CRL * GPIOB_CRL      = (volatile GPIOx_CRL *)(GPIOB_BASE	+0x00);
volatile GPIOx_CRH * GPIOB_CRH      = (volatile GPIOx_CRH *)(GPIOB_BASE +0x04);
volatile GPIOx_IDR * GPIOB_IDR      = (volatile GPIOx_IDR *)(GPIOB_BASE +0x08);
volatile GPIOx_ODR * GPIOB_ODR      = (volatile GPIOx_ODR *)(GPIOB_BASE +0x0C);

void clockInit(void){

	RCC_APB2ENR->bits.IOPAEN = 0b1;
	RCC_APB2ENR->bits.IOPBEN = 0b1;
}

void gpioInit(void){

	GPIOA_CRL->bits.MODE1 = 0b00;
	GPIOA_CRL->bits.CNF1  = 0b01;

	GPIOB_CRL->bits.MODE1 = 0b10;
	GPIOB_CRL->bits.CNF1  = 0b00;

	GPIOA_CRH->bits.MODE13 = 0b00;
	GPIOA_CRH->bits.CNF13  = 0b01;

	GPIOB_CRH->bits.MODE13 = 0b10;
	GPIOB_CRH->bits.CNF13  = 0b00;

	GPIOB_ODR->ALL_FIELDS  = 0xFFFFFFFF;
}
void delay(int d){

	unsigned long i,j;
	for(i=0;i<d;i++)
		for(j=0;j<255;j++);
}

int main(void)
{
	clockInit();
	gpioInit();

	while(1){

		if(GPIOA_IDR->bits.IDR1 == 0b0){

			GPIOB_ODR->bits.ODR1 ^= 0b1;
			while(GPIOA_IDR->bits.IDR1 == 0b0);
		}
		if(GPIOA_IDR->bits.IDR13 == 0b1){

			GPIOB_ODR->bits.ODR13 ^= 0b1;
			delay(1);
		}

	}
}
