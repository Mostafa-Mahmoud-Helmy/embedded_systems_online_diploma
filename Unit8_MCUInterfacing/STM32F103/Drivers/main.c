/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "stm32f103c6_usart_driver.h"
#include "stm32f103c6_spi_driver.h"
#include "stm32f103c6_gpio_driver.h"
#define SLAVE
#ifdef MASTER
void My_Response(void){

	char data;
	data = MCAL_USART_receive(USART1, disable);
	MCAL_USART_transmit(USART1, data, enable);
	MCAL_GPIO_writePin(GPIOA, GPIO_PIN4, GPIO_LOW);
	MCAL_SPI_TxRx(SPI1, data, enabled);
	MCAL_GPIO_writePin(GPIOA, GPIO_PIN4, GPIO_HIGH);
}
#endif

#ifdef SLAVE
void SPI_ISR_CallBack(void){
	char data;
	data = MCAL_SPI_TxRx(SPI1, 0, disabled);
	MCAL_USART_transmit(USART1, data, enable);
}
#endif
void clockInit(void){
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();
	RCC_USART1_CLK_EN();
	RCC_SPI1_CLK_EN();
}

int main(void){

	USART_config cfg;
	SPI_config conf;
	clockInit();

	cfg.USART_BaudRate  = USART_BR_115200;
	cfg.USART_DataBits  = USART_8_DATA_BITS;
	cfg.USART_ParityBit = USART_NO_PARITY;
	cfg.USART_StopBits  = USART_1_STOP_BIT;
	cfg.USART_Mode		= USART_MODE_TX_RX;
#ifdef MASTER
	cfg.USART_ISREnable = USART_ISR_ENABLE_RXNE;
	cfg.USART_P_ISR_CallBack	= My_Response;
#endif
#ifdef SLAVE
	cfg.USART_ISREnable = USART_ISR_ENABLE_NONE;
	cfg.USART_P_ISR_CallBack	= NULL;
#endif
	MCAL_USART_init(USART1, &cfg);


	conf.SPI_BaudRatePrescaler = SPI_BR_PRESCALER_8;
	conf.SPI_ClkPolarity	   = SPI_CLKPOL_LOW_WHEN_IDLE;
	conf.SPI_ClkPhase		   = SPI_CLKPHA_FIRST_EDGE_SAMPLE;
	conf.SPI_DataFrameBits	   = SPI_DFF_8_BITS;
	conf.SPI_BitOrder	   	   = SPI_BITORDER_MSBFIRST;

#ifdef MASTER
	conf.SPI_Mode 			   = SPI_MODE_MASTER;
	conf.SPI_NSS			   = SPI_NSS_SOFTWARE_SET;
	conf.IRQ_Enable			   = SPI_IRQ_DISABLE;
	MCAL_SPI_init(SPI1, &conf);
	GPIO_config cof;
	cof.GPIO_PinNumber = GPIO_PIN4;
	cof.GPIO_PinMode   = GPIO_MODE_OUTPUT_PP;
	cof.GPIO_OutputSpeed = GPIO_SPEED_10M;
	MCAL_GPIO_init(GPIOA, &cof);
	MCAL_GPIO_writePin(GPIOA, GPIO_PIN4, GPIO_HIGH);
#endif
#ifdef SLAVE
	conf.SPI_Mode 			   = SPI_MODE_SLAVE;
	conf.SPI_NSS			   = SPI_NSS_HARDWARE_OUTPUT_DISABLE;
	conf.IRQ_Enable			   = SPI_IRQ_RXNEIE;
	conf.SPI_P_ISR_CallBack	   = SPI_ISR_CallBack;
	MCAL_SPI_init(SPI1, &conf);
#endif
	while(1){
	}

}


